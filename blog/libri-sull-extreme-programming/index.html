<html>
<head>
    <title>[Italian] Libri sull’Extreme Programming</title>
    <link rel="stylesheet" href="../../style.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73813545-1', 'auto');
  ga('send', 'pageview');

</script>
<h1>[Italian] Libri sull’Extreme Programming</h1>
<small><small>(Article copied from my <a href="http://www.summarify.com/ita/libri-sullextreme-programming/">old blog</a>)</small></small>
<div class="entry-content">
    <section>
        <div id="attachment_29" style="width: 330px" class="wp-caption alignright"><img class=" wp-image-29    " style="margin: 0px;" alt="Extreme Programming Explained" src="http://www.summarify.com/wp-content/uploads/2013/04/extremeprogramming.png" width="300" height="267"></div>
        <p>Extreme Programming è una metodologia di sviluppo software, conosciuta anche con l’abbreviazione di XP, appartenente alla famiglia delle metodologie Agile che stanno prendendo sempre più campo.</p>
        <p>In questo articolo parlerò di due libri sull’Extreme Programming, libri che mi hanno consigliato e che si sono dimostrati particolarmente validi:</p>
        <ul>
            <li><a href="http://www.amazon.it/gp/product/0321278658/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0321278658&amp;linkCode=as2&amp;tag=summarify-21" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.amazon.it/gp/product/0321278658/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0321278658&amp;linkCode=as2&amp;tag=summarify-21', 'Extreme Programming Explained: Embrace Change');">Extreme Programming Explained: Embrace Change</a><img src="http://www.assoc-amazon.it/e/ir?t=summarify-21&amp;l=as2&amp;o=29&amp;a=0321278658" width="1" height="1" border="0" alt="" style="border: none !important; margin: 0px !important; display: none !important;">
            </li>
            <li><a href="http://www.amazon.it/gp/product/0201710919/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0201710919&amp;linkCode=as2&amp;tag=summarify-21" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.amazon.it/gp/product/0201710919/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0201710919&amp;linkCode=as2&amp;tag=summarify-21', 'Planning Extreme Programming');">Planning Extreme Programming</a><img src="http://www.assoc-amazon.it/e/ir?t=summarify-21&amp;l=as2&amp;o=29&amp;a=0201710919" width="1" height="1" border="0" alt="" style="border: none !important; margin: 0px !important; display: none !important;">
            </li>
        </ul>
        <p>Autore (o co-autore nel secondo caso) dei libri, Kent Beck è una “<em>superstar</em>”  <span id="more-253"></span> del panorama sviluppo software Agile: tra i 17 autori dell’originale manifesto Agile, è stato tra il <em>creatore della metodologia di sviluppo <strong>Test Driven Development</strong></em> e <em>tra i creatori dell’<strong>Extreme Programming</strong></em> stesso. Dal punto di vista software, il suo contributo più grande al mondo degli sviluppatori Java è stato senza dubbio la creazione del framework per il testing <strong>JUnit</strong>.</p>
    </section>
    <section>
        <h1>Extreme Programming Explained – di Kent Beck</h1>
        <h2>Che cos’è l’Extreme Programming</h2>
        <p>XP prende un insieme di regole di “buon senso”, applicandole fino ad “estremi” livelli. Queste regole di buon senso permettono ai programmatori di lavorare su quello che importa davvero, permettendo di vedere concretamente i progressi sugli obiettivi di interesse, anche ai manager e ai clienti in modo di permetter loro di modificare eventualmente il corso del progetto prima che sia troppo tardi (XP riduce i rischi del progetto, riduce i tempi di risposta a modifiche nelle specifiche ed aumenta la produttività dei programmatori.</p>
        <h3>Punti base dell’Extreme Programming</h3>
        <p>Forse con un pò troppa benevolenza XP viene definito da Kent Beck come una metodologia leggera, efficiente, flessibile, predicibile, scientifica e divertente per lo sviluppo del software. Si distingue dalle altre metodologie per:</p>
        <ul>
            <li>Concretezza, rapidità e capacità di fornire feedback continuo grazie a cicli di sviluppo brevi</li>
            <li>Approccio di pianificazione incrementale, che permette di creare un piano in continua evoluzione durante la vita del progetto</li>
            <li>Pianificazione flessibile dell’implementazione delle funzionalità, in risposta alle modifiche richieste dai clienti</li>
            <li>Affidabilità grazie ai test automatici, che permettono di osservare in ogni momento l’evoluzione dei progressi, risolvendo eventuali problemi prontamente</li>
            <li>Affidamento sulla comunicazione orale, sui test e sul codice sorgente per comunicare la struttura e l’intento del sistema</li>
            <li>E’ orientato a progetti realizzabili da team da 2 a 10 programmatori</li>
        </ul>
        <h3>I problemi delle metodologie classiche di sviluppo</h3>
        <p>Il problema principale dello sviluppo software è dato dal <strong>rischio</strong>. Il rischio può essere di vario tipo: slittamenti temporali, cancellazione del progetto, <em>defect rate</em> (difettosità) del sistema tale da rendere inutilizzabile lo stesso, incomprensione delle specifiche di business, modifiche alle specifiche di business, funzionalità fasulle (divertenti da programmare, ma inutili per il cliente), turnover dello staff (i programmatori iniziano ad odiare il programma e lo lasciano).</p>
        <p>XP cerca di rimediare a tutto ciò:</p>
        <ul>
            <li>SLITTAMENTI -&gt; grazie ai brevi cicli di rilascio del software, la dimensione di eventuali slittamenti è limitati; per ogni rilascio XP usa iterazioni di 1-4 settimane per rilasciare specifiche features richieste dal processo; all’interno di una iterazione vengono definiti task più piccoli da completare, da 1-3 giorni.</li>
            <li>CANCELLAZIONE DEL PROGETTO -&gt; grazie alle release di piccole dimensioni è meno probabile </li>
            <li>DEFECT RATE -&gt; vengono eseguiti test continuamente, sia dai programmatori (funzione per funzione) che dai clienti (feature per feature)</li>
            <li>INCOMPRENSIONE DELLE SPECIFICHE -&gt; il cliente nell’XP è una parte integrale del team di sviluppo: le specifiche sono continuamente raffinate durante lo sviluppo</li>
            <li>MODIFICHE ALLE SPECIFICHE -&gt; con brevi cicli di release è più difficile che queste vengano modificate</li>
            <li>FALSE FEATURE -&gt; utilizzando XP si cerca di concentrarsi sui task ad alta </li>
            <li>STAFF TURNOVER -&gt; il programmatore ha sotto occhio il piano, conosce quali sono le tempistiche, è più difficile che risulti frustrato e voglia andarsene</li>
        </ul>
        <h3>Variabili nel modello progettazione software</h3>
        <p>Sono quattro: COSTO, TEMPO, QUALITA’, FEATURES.</p>
        <p>XP cerca di rendere le quattro variabili costantemente monitorabili a tutti: programmatori, clienti e manager. Monitorando le variabili i manager e i clienti loro possono decidere quali variabili controllare e sulle quali lasciare libertà agli sviluppatori.</p>
        <p><strong>Costi</strong><br>
            Troppo denaro può creare più problemi di quelli che risolve, mentre troppo poco non permetterà la risoluzione dei problemi di business</p>
        <p><strong>Tempi</strong><br>
            Allungare i tempi a disposizione può aumentare le features e la qualità, ma dato che il miglior feedback è quello che si ottiene dal sistema finito, troppo tempo a disposizione è dannoso.</p>
        <p><strong>Qualità</strong><br>
            Posso guadagnare sul tempo tagliando in qualità, ma potrei avere problemi di risorse umane, tecniche e feature notevoli. Inoltre bisogna specificare che la qualità è di due tipi <strong>esterna</strong>, cioè misurata dai clienti ed <strong>interna</strong> cioè quella misurata dai programamtori.</p>
        <p><strong>Features</strong><br>
            Con meno feature posso aumentare la qualità, devo comunque tenere a mente di risolvere il problema principale.</p>
        <h4>Interazione tra le variabili</h4>
        <p>Non è semplice e lineare: l’esempio più classico:</p>
        <p><strong>Non posso semplicemente ridurre i tempi aumentando il budget</strong></p>
        <p>Non posso aumentare semplicemente i programmatori per ridurre i tempi di consegna: ad esempio non posso partire con 40 programmatori, dovrò partire con un piccolo team e poi incrementarlo (un team da 10, poi 2 e poi 4).</p>
        <h2>I benefici della Extreme Programming</h2>
        <h3>Il costo delle modifiche</h3>
        <p>XP permette di mantenere il costo di eventuali modifiche il più basso possibile. Tradizionalmente una modifica in fase di produzione costa esponenzialmente di più a mano a mano che si superano le fasi raccolta dei requisiti, analisi, design, implementazione , eccetera.</p>
        <p>XP tiene questa curva più o meno costante, grazie alla sua natura.</p>
        <h3>Feedback</h3>
        <p>Nella XP il feedback è rapido: esso è fondamentale per l’apprendimento. Una volta in produzione esso è anche più significativo, ottenendo il feedback, ed interpretando è possibile reimmettere tutto ciò che si è appreso dall’interpretazione del feedback il più velocemente possibile.</p>
        <p>Il feedback è quello in generale fornito dagli utenti, e si differenzia dai test.</p>
        <h3>Test</h3>
        <p>I test vengono eseguiti dai programmatori, sono sia una risorsa che una responsabilità: non basta scrivere il test, e considerare conclusa la faccenda, bisogna assicurarsi che questi saranno eseguiti e che coprano tutte le varie eventualità.</p>
        <p>La realizzazione di una suite di test automatica è giustificata da una ragione a lungo termine, ovvero <em>mantenere il programma in vita il più a lungo possibile</em> (aumento la fiducia e la mantenibilità del sistema) ed una a breve termine: <em>è divertente, offre maggior sicurezza al codice</em>.</p>
        <p>Bisogna dire che i test si dividono principalmente in due: gli Unit Test scritti dal programmatore per verificare che funzioni come da loro programmato e quelli funzionali scritti dal cliente per verificare che il sistemi lavori come da loro specificato.</p>
        <h3>Semplicità</h3>
        <p>Bisogna sempre pensare in semplice: ogni problema deve essere considerato estremamente semplice (e difatti lo è), secondo l’autore ben il 98% dei problemi è molto semplice e va risolto subito, in modo da lasciare tempo necessario alla soluzione dei problemi difficili, che sono solo una minima parte. Semplificare il problema è uno dei mantra del Test Driven Development, dove parto con una implementazione essenziale ed aggiungerò complessità in eguito.</p>
        <h3>Modifiche incrementali</h3>
        <p>Si ricollega al punto precedente: eseguire modifiche piccole, grandi cambiamenti tutti assieme funzionano più difficilmente.</p>
        <h3>Design</h3>
        <p>Non basta scrivere codice e test, bisogna organizzare la logica del sistema in qualche struttura. Un buon design:</p>
        <ul>
            <li>Evita la duplicazione del codice</li>
            <li>Rende la struttura non troppo complessa e logica da seguire</li>
            <li>Permette di estendere il sistema aggiungendo nuove funzionalità senza stravolgere tutto</li>
        </ul>
        <h3>Comunicazione aperta e onesta</h3>
        <p>Bisogna dirsi quando ci sono problemi nel codice, essere liberi di esprimere le proprie paura, e supportarle. Bisogna inoltre saper comunicare le cattive notizie anche a manager e customer, e il più presto possibile.</p>
        <h2>Mettere in pratica la XP</h2>
        <p>Finora sono stati visti i principi generali, ora sarà visto come applicare in pratica la XP:</p>
        <h3>1° Fase: pianificazione</h3>
        <p>I clienti, alle “business people” devono specificare: FEATURES RICHIESTE, PRIORITA’ DELLE FEATURES, COMPOSIZIONE DELLE RELEASE, DATE DELLE RELEASE.</p>
        <p>I programmatori devono decidere: STIME TEMPORALI, PROCESSO DI SVILUPPO (team, membri, modalità di lavoro), ORGANIZZAZIONE DEL PIANO (quali feature per prime? quando?)</p>
        <h3>2° Fase: piccole release</h3>
        <p>Si parte subito a lavorare, rilasciando release il più piccole possibili, che implementano la maggior parte dei requisiti.</p>
        <p><strong>Design semplice</strong><br>
            Si punti a ottenere un design semplice nelle vari release, il design giusto è quello che: funziona (i test vengono completati con successo), non contiene logica duplicata, esprime le intenzioni dei programmatori, e soprattutto <em>ha il minimo numero possibile di classi e di metodi</em>.<br>
            Un design semplice implica un investimento iniziale ridotto, che sarà appesantito in seguito dalle modifiche incrementali: la cosa fondamentale è evitare di scrivere codice per <em>quello che penso mi possa servire dopo</em>.</p>
        <p><strong>Strategie di testing</strong><br>
            E’ impossibile testare assolutamente tutto, il test diventerebbe complicato e probabile contenitore di errori come il codice originale. Ma devo assicurarmi di testare <em>tutto quello che potrebbe essere rotto</em>.<br>
            I test devono essere presenti per ogni feature del programma, sia unit test che test funzionali (scritto dal cliente, storia per storia). Non importa che ci siano test per ogni metodo, ma solo per quei metodi che potrebbero non funzionare.<br>
            Nell’ottica del Test Driven Development, può essere utile scrivere i test ancor prima dell’implementazione, questo è utile soprattutto nel caso in cui l’interfaccia non sia del tutto chiara. Un altro caso in cui un test è d’aiuto è nel caso si identifichi un problema: scrivo un test apposito per quel problema, ed eseguendolo mi assicurerò che il problema sia stato risolto:<em> bisogna prima scrivere il test e poi fixare il problema</em>!</p>
        <p>Ci sono poi altri tipi di test, ad esempio i <strong>Parallel Test</strong> nei quali verifico che un nuovo sistemi funzioni allo stesso modo del prevcedente che va a sostituire, oppure lo <strong>Stress test</strong> (non ha bisogno di presentazioni) o il <strong>Monkey test</strong> che si occupa di assicurarsi che di fronte ad un input senza senso il sistema agirà in modo appropriato.</p>
        <p><strong>Continuous Integration</strong> o integrazione continua è la parola chiave: il codice è integrato e testato dopo un paio di ore, un giorno di sviluppo al massimo: è importante avere tool che supportano test veloci di integrazione/build/testing.</p>
        <p>Il vantaggio di questo approccio è che se un bug emerge una volta inserito nel sistema, mi ricordo come è stata scritta la feature perchè è stato fatto in giornata, e debuggherò al meglio.</p>
        <h3>Rifattorizzare</h3>
        <p>Quando si implementa una feature, ci si accorge sempre che si potrebbe modificare il programma esistente per rendere l’aggiunta della nuova feature più semplici. Si può sempre migliorare il sistema, ma bisogna farlo solo quando è necessario, ad esempio per rimuovere codice duplicato o se la modifica è ovvia e prenderà poco tempo (10 min).</p>
        <h3>Pair programming</h3>
        <p>Questa è una feature di XP molto peculiare, il codice di produzione si scrive con 2 persone per pc. Uno ha tastiera e mouse e pensa al miglior modo per implementare un metodo, l’altro pensa più strategicamente (questo approccio funzionerà? Quali possono essere i test case da inserire qua? In quale modo i test possono fallire? C’è modo di semplificare il sistema in modo che il problema scompaia?)</p>
        <p>Le coppie possono essere dinamiche e scambiate con altre persone.</p>
        <h3>On-Site customer</h3>
        <p>E’ necessario avere i clienti (o almeno una persona di riferimento) disponibile per il team per rispondere a domande, risolvere dubbi e dispute e stabilire le priorità. Deve essere una persona che utilizzerà il sistema in produzione, non un manager esterno al tutto.</p>
    </section>
    <hr>
    <section>
        <h1>Planning Extreme Programming – di Kent Beck e Martin Fowler</h1>
        <p>Questo secondo libro è più dedicato alla pianificazione nell’ambito XP. La pianificazione è importante per vari motivi:</p>
        <ul>
            <li>Assicurarci in ogni momento di lavorare alla cosa giusta (la più importante)</li>
            <li>Coordinare al meglio il lavoro tra più persone</li>
            <li>Comprendere le conseguenze a livello dei primi due punti quando succedono eventi inattesi</li>
        </ul>
        <p>La pianificazione esiste a vari livelli: a livello giornaliero per le attività del giorno, a livello annuale per quanto riguarda lo sviluppo lato business, eccetera. In ogni caso la pianificazione ad ogni livello consiste nell’individuare un probabile corso degli eventi, in modo da potersi attenere in linea di massima a quello e rimediare in caso di inevitabili cambiamenti che possono accadere.</p>
        <p>E’ fondamentale che un piano però, affinché funzioni, sia aggiornato, con tutti i progressi raggiunte ed informazioni aggiornate, in caso contrario è destinato ad essere un peso o comunque poco utile. Bisogna capire che <em>lo scopo principale di un piano non è controllare gli eventi, ma controllare la proprie reazioni agli eventi</em>: vedendo questa definizione risulta più evidente come avere informazioni aggiornate è fondamentale per gestire le reazioni.</p>
        <p>Ovviamente ad un evento inaspettato seguirà una reazione e un aggiustamento al piano, è fisiologico quindi, che il piano si evolva.</p>
        <h2>Perchè un piano? Per proteggersi dalle paure</h2>
        <p>La realizzazione di un software è rischiosa, molte cose possono andare storte. Un piano è un parziale scudo, un supporto, non garantisce nulla ma comunque da una sicurezza in più.</p>
        <p>In particolare esistono varie paure, i clienti hanno paura che le loro specifiche non saranno soddisfatte, saranno incomplete o mal comprese, pagheranno troppo per troppo poco, saranno nelle mani di tecnici a cui non importa, non comprenderanno i piani o questi saranno irrealizzabili, non capiranno cosa sta succedendo, saranno condizionati dalle loro prime scelte e impediti a modificare qualcosa per reagire a modifiche richieste dal mercato.</p>
        <p>Le paure degli sviluppatori sono diverse: gli sarà chiesto di fare cose al di sopra delle loro possibilità, o che addirittura non hanno senso, saranno investiti di responsabilità senza avere l’autorità necessaria, non avranno specifiche chiare, dovranno sacrificare la qualità sull’altare delle scadenze, dovranno risolvere complessi problemi senza aiuto, non avranno abbastanza tempo per completare il lavoro.</p>
        <p>Tutte queste paure vanno messe nero su bianco per evitare che si concretizzano, solo in questo modo ci si protegge, definendo una sorta di carta dei diritti del cliente ed una dello sviluppatore.</p>
        <p><strong>La carta dei diritti del programmatore</strong></p>
        <ul>
            <li>Ha il diritto di sapere che cosa è richiesto, con una chiara definizione della priorità</li>
            <li>Ha il diritto di produrre un lavoro di qualità, sempre</li>
            <li>Ha il diritto di richiedere ed ottenere aiuto da colleghi, manager, e clienti</li>
            <li>Ha il diritto di fare e aggiornare le proprie stime</li>
            <li>Ha il diritto di accettare le responsabilità consapevolmente invece di vedersele imposte dall’alto</li>
        </ul>
        <p><strong>La carta dei diritti del cliente</strong></p>
        <ul>
            <li>Ha il diritto di pianificare a livello generale, di sapere con precisione cosa sarà conseguito e a che costo</li>
            <li>Ha il diritto di ottenere il maggior valore possibile dalla settimana di programmazione</li>
            <li>Ha il diritto di cambiare idea, sostituire funzionalità e cambiare priorità senza dover affrontare incrementi dei costi esorbitanti</li>
            <li>Ha il diritto di vedere i progressi in un sistema in esecuzione, e di veder passare determinati test specificati da lui stesso</li>
            <li>Ha il diritto di essere informato in cambi di tempi di consegne, in tempo per scegliere come ridurre o modificare le feature se è fondamentale tornare al tempo di consegna prestabilito.</li>
            <li>Ha il diritto di cancellare il progetto in ogni istante ed avere in mano un sistema parzialmente funzionante che rifletta l’investimento fino al momento</li>
        </ul>
        <p>In quest’ottica del programmatore vs cliente, è importante stabilire un equilibrio di poteri: chi comanda?</p>
        <p>Per quel che riguarda le decisioni di business, il cliente, per quel che riguarda le decisioni tecniche, i tecnici. Ad esempio, dati dei <em>requisiti</em>, delle d<em>ate di consegna</em> e delle <em>priorità</em> da parte dei clienti, le stime devono essere fatte dai programmatori (tecnici), che diranno se una cosa è o meno possibile.</p>
        <p>Ma chi deve essere il cliente? Nella pianificazione è importante avere una persona rappresentante dell’azienda cliente che abbia determinate caratteristiche se vuole facilitare il compito degli sviluppatori. In particolare deve comprendere bene il dominio di business, comprendere come il software apporterà valore al dominio, non aver paura di stabilire obiettivi intermedi troppo piccoli, purchè portino valore, saper stabilire le priorità tra varie funzionalità, essere disposto ad avere la sua fetta di responsabilità nel fallimento o successo del progetto (quest’ultimo punto è il più gravoso sicuramente).</p>
        <h2>Panoramica sul processo XP</h2>
        <p>Le release sono di alcuni mesi, divise al loro interno in iterazioni di 1-2 settimane, suddivise a loro volta in task di alcuni giorni.</p>
        <p>La pianificazione permette di assegnare <strong>Storie</strong> (frammenti di funzionalità) in release ed iterazioni, in reazione ad eventuali reazioni nello sviluppo.</p>
        <p>Spesso il problema nel lavoro è <strong>troppo da fare e/o troppo poco tempo</strong>. In realtà ci si concentra sulla seconda parte del problema e non a sufficienza sul primo. Non possiamo manipolare più di tanto il tempo, ma sul <em>troppo da fare</em> si può lavorare: è possibile prioritizzare alcune cose, ed eliminarne o ridurre la dimensione di altre, oppure, potremmo chiedere aiuto per alcune parti del problema.</p>
        <h3>La stima dei tempi</h3>
        <p>E’ un aspetto cruciale nella pianificazione. Come si fa? La regola più semplice è misurare la produttività di un giorno e assumere che sarà la stessa di domani.</p>
        <h3>Iniziare un progetto</h3>
        <p>Dove iniziare? Principalmente da quattro fattori:</p>
        <ul>
            <li>Gli <strong>oggetti</strong>, le storie principali che necessitano un software da implementare</li>
            <li>Il prezzo: la stima dei tempi di implementazione di ciascuna storia</li>
            <li>Il <strong>budget</strong>: quante persone saranno necessarie per completare il progetto</li>
            <li><strong>Vincoli </strong>forniti da qualcuno con conoscenze funzionali sull’argomento</li>
        </ul>
        <h3>Sincronizzare progetto e business</h3>
        <p>Una volta stabilito grosso modo il progetto dal punto di vista tecnico, occorre sincronizzarlo con due esigenze dell’azienda cliente:</p>
        <ul>
            <li>Date di release</li>
            <li>Feature da implementare ad ogni release, quindi quali user stories</li>
        </ul>
        <p>E’ importante sottolineare che il cliente parla in termini di <strong>user stories</strong>, deve elencarle, darle un peso e appunto decidere quali vorrà implementate per ogni release. <strong>Il piano delle release non è stabile</strong>, a causa di imprevisti durante lo sviluppo, cambiamenti di idea del cliente, oppure aumento nella produttività degli sviluppatori.</p>
        <p>Il piano è solo uno snapshot momentaneo per dare un’idea al cliente/programmatori di che cosa aspettarsi, ma come detto sarà sicuramente modificato.</p>
        <h3>Orizzonte temporale della pianificazione</h3>
        <p>Che orizzonte temporale deve avere il piano? Fin quanto in là deve spingersi?</p>
        <p>Si tratta di un tradeoff: più avanti vado con la pianificazione meno dettagli avrò, e quindi vedere troppo in là diventa poco significativo. Viene suggerito nel libro di pianificare 1-2 iterazioni e 1-2 release, non di più.</p>
        <p>Concentrarsi su poche release/iterazioni permette al programmatore di focalizzare le proprie attenzioni sulle user stories che contano e le successive, trascurando le altre. Al cliente invece interessa sapere quali sono le funzionalità che sono in corso di implementazione e che quindi avrà a disposizione dalla prossima release.</p>
        <h3>Pianificazione dell’infrastruttura del progetto</h3>
        <p>Per infrastruttura si intendono quelle funzionalità come framework per GUI, oggetti distribuiti, persistenza dei database, eccetera.</p>
        <p>Per partire il più veloce possibile non sceglierò l’infrastruttura definitiva ancor prima di iniziare, sceglierò l’infrastruttura a mano a mano che sarà necessario, che il suo utilizzo sarà previsto all’interno dell’iterazione in programma.</p>
        <p>L’infrastruttura può poi evolversi con l’evoluzione del progetto, se il design è stato fatto bene con alta riusabilità e le giuste interfacce, sarà possibile modificare in seguito l’infrastruttura.</p>
        <h3>Scrivere le user stories</h3>
        <p>La storia è l’<em>unità di funzionalità</em> in un progetto XP. Il progresso di un progetto XP è misurato in storie consegnate, integrate all’interno nel sistema. </p>
        <p>Una storia deve essere <strong>comprensibile</strong> (per il cliente, in linguaggio naturale), <strong>testabile</strong>, <strong>apportare un qualche valore</strong> al cliente, ma essere allo stesso tempo sufficientemente piccola da rendere possibile la realizzazione di diverse (5?) all’interno di un’iterazione.</p>
        <p>Se una user story è troppo grande, sarà suddivisa in due o più storie, le quali durate saranno stimate, prioritizzate dal cliente eccetera.</p>
        <p>Creare una scala di priorità tra le storie è molto importante: prima vanno implementate quelle storie che forniscono il più alto valore all’utente, facendo però attenzione alle dipendenze tra storie. Per misurare il valore di una storia, bisogna rivolgersi al cliente, non possono farlo i project manager ne i programmatori (in questo modo si delega anche parte delle responsabilità).</p>
        <p>E’ importante specificare che non si finisce mai di scrivere storie, un progetto può cambiare in corsa, oppure posso suddividere storie esistenti, la scrittura delle storie va avanti in continuazione.</p>
        <p>Per stimare il tempo necessario a implementare una storia, come regola generale si confronta con il tempo utilizzato per implementare una storia simile in precedenza. Se non esiste nessuna storia pre-implementata simile, mi atterrò all’esperienza, prendendone una grande il doppio e dividendo per due, ad esempio.</p>
        <h2>Le iterazioni</h2>
        <p>Una iterazione è un contenitore, al suo interno svilupperò alcune storie. Quante? Dipende dalla durata dell’iterazione e dalla stima delle storie.</p>
        <h2>Modifiche al piano: come reagire</h2>
        <h3>Cambio di priorità di una storia</h3>
        <p>Non comporta nulla di particolare, nel business è possibile che ci sia un cambio di priorità secondo nuove valutazioni o informazioni aggiornate.</p>
        <h3>Aggiunta di una storia</h3>
        <p>Una delle principali differenze di XP da altre metodologie è che non sono fornite inizialmente una serie enorme di specifiche dettagliate. I requisiti possono fluire a mano a mano durante la vita del progetto, per accompagnare anche modifiche ai requisiti desiderati dal cliente o dal mercato stesso.</p>
        <h3>Ricostruire il piano delle release</h3>
        <p>Con molte modifiche a molte storie, potrebbe modificarsi molto il deliverable di una release. In particolare ricostruirò il piano delle release quando:</p>
        <ul>
            <li>Ho troppe storie posticipate rispetto al piano originale</li>
            <li>La velocità di sviluppo del team cambia, e le assunzioni precedenti non sono più valide</li>
        </ul>
        <p><strong>Come si ricostruisce un piano?</strong><br>
            Bisogna stimare nuovamente le storie, ora con maggior esperienza e quindi maggior precisione.</p>
        <p>Il cliente deve poi selezionare tra le storie quelle a maggior priorità e che vorrà per prime, all’interno della prossima release.</p>
        <p>Di solito il piano sarà ricostruito ogni tre o quattro iterazioni, non ogni volta perchè comunque richiede tempo, ma va fatto regolarmente.</p>
        <h2>Realizzare il primo piano</h2>
        <p>Abbandonando l’argomento dei piani successivi che vanno ricostruiti, gli autori del libro ricordano che comunque <em>il piano più importante, il più difficile da realizzare, è il primo</em>. </p>
        <p>I punti di incertezza durante la realizzazione del primo piano sono la velocità di sviluppo del team, e la dimensione (o meglio granularità) delle storie. Col tempo ci saranno riferimenti per la velocità (bastano 1-2 iterazioni), mentre per stimare le storie non ci sono raccomandazioni particolari.</p>
        <p>Nella creazione di un piano, per ogni iterazione oltre a pianificazione, sviluppo e test bisogna inserire anche aspetti che coinvolgono meno i programmatori e che magari potrebbero dimenticare/sottovalutare, cioè eseguire i test di accettazione (o funzionali) specificati dal cliente, pianificare l’iterazione stessa, e comunicare i progressi al management.</p>
        <h2>Iniziare a programmare</h2>
        <p>Una volta realizzato il piano si inizierà a programmare. Alcuni consigli degli autori del libro sono:</p>
        <ul>
            <li>Preparare il framework per il testing</li>
            <li>Preparare una struttura per il build rapido</li>
            <li>Impostare la rete ed i permessi adatti</li>
            <li>Predisporre vari script base di installazione</li>
        </ul>
        <p>Questo risparmierà tempo in seguito e una volta che si partirà con lo sviluppo vero e proprio del software ci si concentrerà su quello.</p>
        <h2>Modifiche locali al piano originale</h2>
        <p>Possono essere release anticipate o più brevi, più lunghe, storie più brevi, eccetera.</p>
        <p>Ad esempio potrebbe essere necessario rilasciare release più spesso, magari ogni iterazione: in quel caso i 2 concetti concidono e conviene abbandonare del tutto le release a concentrarsi sulle iterazioni.</p>
        <p>Oppure potrebbe essere necessario avere delle release più lunghe, ad esempio un anno, ad esempio nel caso vada sostituito un sistema preesistente, e non è possibile farlo parzialmente.</p>
        <p>Nel caso di storie più piccole invece, potrebbero essere richieste per una iterazione 25 storie da 2 giorni di lavoro piuttosto che 4 da 2 settimane, è la stessa cosa, ma con le storie più brevi il cliente ha un controllo più puntuale.</p>
        <h2>Pianificare una singola iterazione</h2>
        <p>Esiste un piano per l’iterazione, che la suddivide in task di alcuni giorni, ciascuno con un programmatore responsabile per il suo completamento.</p>
        <p>Il programmatore da una stima durante la riunione iniziale dell’iterazione, assieme ad un feedback al cliente o al project manager per dimostrare di aver compreso bene la storia. Durante la riunione inoltre vengono elencati i task dell’iterazione, con alcune dipendenze tra gli stessi.</p>
        <p>Dopo la riunione iniziale inizia il lavoro vero e proprio: i task vanno implementati, ed i progressi tracciati. Durante un’iterazione ciascun membro tiene traccia dei suoi progressi e se qualcosa va a rilento il Project Manager può aggiungere risorse addizionali o bilanciare in qualche modo le storie successive per compensare il ritardo. Può anche succedere il contrario (uno sviluppatore con extra time), e in quel caso si utilizzerà la risorsa in eccedenza per bilanciare la situazione.</p>
        <p>L’aspetto fondamentale da tenere sotto controllo è “<em>che cosa resta ancora da fare</em>“, perché è legato alla data di release.</p>
        <h2>Gestione dei bug nell’XP</h2>
        <p>In fase di pianificazione vanno previsti dei tempi per la risoluzione dei bug. Eventualmente il cliente potrà scegliere se preferisce che tutti i bug siano fixati in una release o nell’avere delle storie (funzionalità) in più implementate (alla fine il tempo è limitato, o sarà utilizzato per cercare di correggere tutti i bug o per progredire con le altre storie).</p>
        <p>Se si riceve dal cliente la richiesta di fixare un bug, è come se ci venisse chiesta una nuova funzionalità, e va trattata esattamente allo stesso modo: con specifiche, dettagli sulla priorità, eccetera. E il tutto sarà integrato alla fine della prossima iterazione. Se un bug invece è critico e non può aspettare, bisogna farlo subito ovviamente.</p>
        <p>Gli autori del libro raccontano di uno dei possibili modi di gestire il bug fixing che per loro ha funzionato, cioè istituire un T<em>eam di Supporto alla produzione</em>, che si concentra appunto nella correzione dei bug.<br>
        </p></section>
    <hr>
    <section>
        <p>Qui si conclude il mio “antipasto” dei libri <a href="http://www.amazon.it/gp/product/0321278658/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0321278658&amp;linkCode=as2&amp;tag=summarify-21" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.amazon.it/gp/product/0321278658/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0321278658&amp;linkCode=as2&amp;tag=summarify-21', 'Extreme Programming Explained: Embrace Change');">Extreme Programming Explained: Embrace Change</a><img src="http://www.assoc-amazon.it/e/ir?t=summarify-21&amp;l=as2&amp;o=29&amp;a=0321278658" width="1" height="1" border="0" alt="" style="border: none !important; margin: 0px !important; display: none !important;"> e <a href="http://www.amazon.it/gp/product/0201710919/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0201710919&amp;linkCode=as2&amp;tag=summarify-21" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.amazon.it/gp/product/0201710919/ref=as_li_ss_tl?ie=UTF8&amp;camp=3370&amp;creative=24114&amp;creativeASIN=0201710919&amp;linkCode=as2&amp;tag=summarify-21', 'Planning Extreme Programming');">Planning Extreme Programming</a><img src="http://www.assoc-amazon.it/e/ir?t=summarify-21&amp;l=as2&amp;o=29&amp;a=0201710919" width="1" height="1" border="0" alt="" style="border: none !important; margin: 0px !important; display: none !important;">, che vi ricordo possono essere acquistati su Amazon (in lingua inglese, non è presente una traduzione italiana del libro).</p></section>
</div>
<ul id="navlist">
    <li class="home"><a href="http://alessio.engineer">Home</a></li>
    <li class="icon linkedin"> <a href="http://www.linkedin.com/in/alessiopiergiacomi"></a></li>
    <li class="icon twitter"><a href="https://twitter.com/alessi0p"></a></li>
    <li class="icon quora"><a href="https://www.quora.com/profile/Alessio-Piergiacomi"></a></li>
    <li class="icon github"><a href="https://github.com/alessiop86"></a></li>
</ul>
</body>
</html>
